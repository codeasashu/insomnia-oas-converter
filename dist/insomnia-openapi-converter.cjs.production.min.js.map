{"version":3,"file":"insomnia-openapi-converter.cjs.production.min.js","sources":["../src/utils/index.ts","../src/exporter.ts","../src/collector.ts","../src/schema.ts"],"sourcesContent":["import {\n  InsomniaResource,\n  InsomniaRequest,\n  Parameter,\n} from '../types/insomnia';\n\nconst insomniaTemplateRegex = /(?<!\\\\){([^{}]+)(?<!\\\\)}/g;\n\nexport const types = {\n  REQUEST: 'request',\n  FOLDER: 'request_group',\n  ENVIRONMENT: 'environment',\n  WORKSPACE: 'workspace',\n  COOKIE: 'cookie_jar',\n  SPEC: 'api_spec',\n};\n\nconst regexes = {\n  workspace: RegExp(/^wrk_[\\w]+$/, 'g'),\n  folder: RegExp(/^fld_[\\w]+$/, 'g'),\n  environment: RegExp(/^env_[\\w]+$/, 'g'),\n};\n\nexport const headerTypes = {\n  JSON: 'application/json',\n  MULTIPART: 'multipart/form-data',\n  FORM: 'application/x-www-form-urlencoded',\n};\n\nexport const getRequestFromFolder = (\n  resource: InsomniaResource,\n  resources: InsomniaResource[]\n): InsomniaRequest | null => {\n  let foundRequests = resources.filter((r) => r.parentId == resource._id);\n  if (foundRequests.length) {\n    return <InsomniaRequest>foundRequests.pop();\n  }\n  return null;\n};\n\nexport const filterRequestResource = (resource: InsomniaResource): boolean => {\n  return resource._type == types.REQUEST;\n};\n\nexport const isWorkspace = (resourceId: string): boolean =>\n  regexes.workspace.test(resourceId);\n\nexport const isFolder = (resourceId: string): boolean =>\n  regexes.folder.test(resourceId);\n\nexport const getQueryStringParams = (query: string) => {\n  return query\n    ? (/^[?#]/.test(query) ? query.slice(1) : query)\n        .split('&')\n        .reduce((params: any, param) => {\n          // @TODO Fix this \"any\" type\n          let [key, value] = param.split('=');\n          params[key] = value\n            ? decodeURIComponent(value.replace(/\\+/g, ' '))\n            : '';\n          return params;\n        }, {})\n    : {};\n};\n\nexport const getTemplateMatches = (\n  variable: string | number\n): Array<string> => {\n  variable = variable.toString();\n  let matches = variable.matchAll(insomniaTemplateRegex);\n  return Array.from(matches).map((m) => m[1].trim());\n};\n\n/**\n * Converts insomnia defined variable holders to openapi variables\n * {{ xyz }} -> { xyz }\n * @param uri string The url to replace the variable\n */\nexport const trimTemplate = (\n  variable: string | number,\n  keepInsomniaFormat: boolean = false\n): string => {\n  variable = variable.toString();\n  // console.log(\"trim1\", variable)\n  let matches = variable.matchAll(insomniaTemplateRegex);\n  for (let match of matches) {\n    let trimmedMatch = match[0].replace('{', '').replace('}', '').trim();\n    let replaceWith = !!keepInsomniaFormat ? `{${trimmedMatch}}` : trimmedMatch;\n    variable = variable.replace(match[0], replaceWith);\n  }\n  return variable;\n};\n\nexport const replaceInsomniaTemplateWithVars = (\n  variable: string | number,\n  envVars: any = {}\n): string => {\n  variable = variable.toString();\n  let matches = variable.matchAll(insomniaTemplateRegex);\n  for (let match in matches) {\n    const trimmedMatch = match[1].trim();\n    variable = variable.replace(match[0], envVars[trimmedMatch] || match[0]);\n  }\n  return variable;\n};\n\nexport const hasHttp = (path: string): boolean =>\n  path.includes('http://') || path.includes('https://');\n\n/**\n * Get a URL instance from insomnia url\n * @param path\n */\nexport const urlFromPath = (path: string): URL => {\n  if (hasHttp(path) === false) {\n    path = `http://${path}`;\n  }\n  return new URL(trimTemplate(path));\n};\n\nexport const parameterizeForm = (\n  insomniaFormParams: Parameter[]\n): {\n  [key: string]: string;\n} => {\n  let bodyParams: any = {};\n  for (let param of insomniaFormParams) {\n    bodyParams[param.name] = param.value;\n  }\n  return bodyParams;\n};\n\nexport const sanitizeRequestMethod = (method: string): string =>\n  method.toLowerCase().trim();\n","import { OpenApiBuilder, OpenAPIObject } from 'openapi3-ts';\nconst yaml = require('js-yaml');\n\nclass SpecExporter {\n  spec: OpenApiBuilder;\n\n  constructor(spec: OpenApiBuilder) {\n    this.spec = spec;\n  }\n\n  as_yaml(): string {\n    return yaml.dump(this.as_dict());\n  }\n\n  as_json(formatted: Boolean): string {\n    const specjson = this.spec.getSpecAsJson();\n    if (formatted === true) {\n      try {\n        return JSON.stringify(JSON.parse(specjson), null, 2);\n      } catch (error) {\n        console.warn('[JSON parseerror]', error);\n        return specjson;\n      }\n    }\n    return specjson;\n  }\n\n  as_dict(): OpenAPIObject {\n    return this.spec.getSpec();\n  }\n}\n\nexport default SpecExporter;\n","import * as insomnia from './types/insomnia';\nimport * as oas from 'openapi3-ts';\nimport * as utils from './utils';\nimport SpecExporter from './exporter';\n\nvar GenerateSchema = require('generate-schema');\n\nconst insoRequestIdKey = 'x-request-id';\n\nclass OpenapiCollector {\n  builder: oas.OpenApiBuilder;\n  envVars: any = {};\n\n  constructor() {\n    this.builder = new oas.OpenApiBuilder();\n  }\n\n  addInfo(config: insomnia.InsomniaConfig): this {\n    this.builder.addTitle(config.title);\n    this.builder.addDescription(config.description);\n    this.builder.addVersion(config.version);\n    this.add_url(config.baseUrl);\n    return this;\n  }\n\n  getRequestFromOas(path: string, method: string): oas.OperationObject | null {\n    let oasPath = oas.getPath(this.builder.rootDoc.paths, path);\n    return (oasPath && oasPath[method]) || null;\n  }\n\n  addFolderToRequest(\n    folder: insomnia.InsomniaFolder,\n    request: insomnia.InsomniaRequest | null\n  ): this {\n    if (request) {\n      let folderName: oas.TagObject = { name: folder.name };\n      this.builder.addTag(folderName);\n      this.updateRequest(request, { tags: [folderName['name']] });\n    }\n    return this;\n  }\n\n  addEnvironment(env: insomnia.InsomniaEnvironment): this {\n    this.envVars = { ...this.envVars, ...env };\n    return this;\n  }\n\n  updateRequest(request: insomnia.InsomniaRequest, args: any): void {\n    let sanitizedMethod = utils.sanitizeRequestMethod(request.method);\n    let { path } = this.get_path_pathparams(request.url);\n    let oasRequest = this.getRequestFromOas(path, sanitizedMethod);\n    if (oasRequest) {\n      let pathObject: oas.PathItemObject = {\n        [sanitizedMethod]: Object.assign({}, oasRequest, { ...args }),\n      };\n      this.builder.addPath(path, pathObject);\n    }\n  }\n\n  get_path_pathparams(\n    url: string\n  ): {\n    path: string;\n    params: oas.ParameterObject[];\n  } {\n    let pathInfo = this._get_oas_pathparams(url);\n    if (pathInfo === null) {\n      throw Error('Valid path is missing from request!');\n    }\n    return {\n      path: pathInfo.path,\n      params: pathInfo.params,\n    };\n  }\n\n  addRequest(request: insomnia.InsomniaRequest): this {\n    let pathItem: oas.PathItemObject = {\n      summary: request.name,\n      description: request.description,\n    };\n\n    let methodName = utils.sanitizeRequestMethod(request.method);\n    let headers = this.insomnia_to_oas_params(request.headers, 'header');\n    let pathInfo = this.get_path_pathparams(request.url);\n    let queryParams = this.get_query_params(request);\n\n    pathItem[methodName] = {\n      parameters: [...headers, ...pathInfo.params, ...queryParams],\n    };\n\n    // If request belongs to folder\n    // if(request.parentId && isFolder(request.parentId)) {\n    //     // @TODO Use folder name instead of folder ids\n    //     pathItem[methodName]['tags'] = [request.parentId]\n    // }\n\n    // Reference request Id\n    pathItem[methodName][insoRequestIdKey] = request._id;\n\n    // If the request has a non-empty body\n    if (Object.keys(request.body).length !== 0) {\n      pathItem[methodName].requestBody = this.get_request_body(request.body);\n    }\n\n    // Add the responses\n    let responses = this.get_responses(request.examples);\n    pathItem[methodName].responses = responses;\n\n    this.builder.addPath(pathInfo.path, pathItem);\n\n    // Add request body\n    return this;\n  }\n\n  get_responses(examples: insomnia.ResponseExample[]): oas.ResponsesObject {\n    let oasResponsesBody = <oas.ResponsesObject>{};\n    let oasResponseBody = { content: <oas.ResponseObject>{} };\n\n    for (let example of examples) {\n      // A base schema without any body\n      let schema;\n      let exampleBody = example.body;\n      if (example.contentType === utils.headerTypes.JSON) {\n        let body = '';\n        try {\n          body = JSON.parse(exampleBody);\n        } catch (e) {\n          console.info(\n            'Response :: Error parsing json body. Using string instead'\n          );\n          body = exampleBody;\n        } finally {\n          schema = this._get_schema(body);\n        }\n      } else {\n        schema = this._get_schema(exampleBody);\n      }\n\n      // Make a copy\n      let responseObject = Object.assign(\n        {},\n        oasResponseBody['content'][example.contentType]\n      );\n\n      let existingSchema = responseObject && responseObject.schema;\n\n      // Use oneOf is there is existing schema for this contentType and\n      // status code\n      responseObject.schema = !!existingSchema\n        ? {\n            oneOf: [...schema, ...existingSchema],\n          }\n        : schema;\n\n      let exampleObj = { [example.id]: example.body };\n\n      responseObject.examples = {\n        ...exampleObj,\n        ...responseObject.examples,\n      };\n\n      oasResponseBody['content'][example.contentType] = responseObject;\n      oasResponsesBody[example.statusCode.toString()] = oasResponseBody;\n    }\n\n    return oasResponsesBody;\n  }\n\n  get_request_body(requestBody: any): oas.RequestBodyObject {\n    let oasRequestBody = { content: <oas.SchemaObject>{} };\n\n    // A base schema without any body\n    let schema, exampleBody;\n\n    // JSON Type\n    if (requestBody.mimeType === utils.headerTypes.JSON) {\n      let jsonBody = {};\n      try {\n        jsonBody = JSON.parse(requestBody.text);\n      } catch (e) {\n        // JSON parse error\n        console.info(\n          'RequestBody :: Error parsing json body. Using string instead'\n        );\n        jsonBody = requestBody.text;\n      } finally {\n        schema = this._get_schema(jsonBody);\n        exampleBody = jsonBody;\n      }\n    } else if (\n      // Form type\n      requestBody.mimeType === utils.headerTypes.FORM ||\n      requestBody.mimeType === utils.headerTypes.MULTIPART\n    ) {\n      let bodyParams = utils.parameterizeForm(requestBody.params);\n      // @TODO beware: filetype uploads are not yet implemented\n      schema = this._get_schema(bodyParams);\n      exampleBody = bodyParams;\n    } else {\n      schema = { additionalProperties: true };\n      exampleBody = requestBody['text'] || requestBody['params'] || {};\n    }\n\n    oasRequestBody['content'][requestBody.mimeType] = {\n      schema,\n      example: exampleBody,\n    };\n\n    return oasRequestBody;\n  }\n\n  get_query_params(request: insomnia.InsomniaRequest): oas.ParameterObject[] {\n    let queryParamsFromurl = this._get_oas_query_params_from_url(request.url);\n    let queryParamsFromParams = this.insomnia_to_oas_params(\n      request.parameters,\n      'query'\n    );\n\n    let urlQueryNames = queryParamsFromurl.map((q) => q.name);\n\n    // pick only those which arent already found in query params\n    let queryParams = queryParamsFromParams.filter(\n      (q) => urlQueryNames.indexOf(q.name) === -1\n    );\n\n    return [...queryParamsFromurl, ...queryParams];\n  }\n\n  _get_from_env(key: any): any {\n    if (this.envVars[key]) return this.envVars[key];\n    return null;\n  }\n\n  add_url(url: string): this {\n    if (utils.hasHttp(url) === false) {\n      return this;\n    }\n\n    const servers = this.builder.rootDoc.servers;\n    if (!servers) {\n      this.builder.addServer({ url });\n      return this;\n    }\n\n    const hasPath = servers.filter((s) => s.url === url);\n    if (hasPath.length === 0) this.builder.addServer({ url });\n    return this;\n  }\n\n  _get_oas_pathparams(\n    uri: string\n  ): {\n    path: string;\n    params: oas.ParameterObject[];\n  } | null {\n    let parsedPath: string = '';\n    let parsedPathParams = [];\n    try {\n      const path = utils.urlFromPath(uri);\n\n      // Add url to host if it is a quialified url\n      this.add_url(path.origin);\n\n      parsedPath = decodeURIComponent(path.pathname);\n      let pathParams = utils.getTemplateMatches(parsedPath);\n      for (let p of pathParams) {\n        parsedPathParams.push(<oas.ParameterObject>{\n          name: p,\n          in: 'path',\n          example: utils.replaceInsomniaTemplateWithVars(p, this.envVars),\n          schema: this._get_schema(p),\n        });\n      }\n    } catch (e) {\n      console.error(e);\n      // @TODO use regex to parse\n      return null;\n    }\n    return { path: parsedPath, params: parsedPathParams };\n  }\n\n  insomnia_to_oas_params(\n    insomniaParams: insomnia.Parameter[],\n    _in: string\n  ): oas.ParameterObject[] {\n    let params = [];\n    for (let param of insomniaParams) {\n      if (param.name && param.name != '') {\n        const _key = utils.replaceInsomniaTemplateWithVars(\n          param.name,\n          this.envVars\n        );\n        const _value = utils.replaceInsomniaTemplateWithVars(\n          param.value,\n          this.envVars\n        );\n        let _param = <oas.ParameterObject>{\n          name: _key,\n          in: _in,\n          example: _value,\n          schema: this._get_schema(_value),\n        };\n        params.push(_param);\n      }\n    }\n    return params;\n  }\n\n  _get_oas_query_params_from_url(path: string): oas.ParameterObject[] {\n    let params = [];\n    try {\n      const url = utils.urlFromPath(path);\n      for (const [key, value] of url.searchParams) {\n        params.push(<insomnia.Parameter>{\n          name: decodeURIComponent(key),\n          value: decodeURIComponent(value),\n        });\n      }\n    } catch (e) {\n      // @TODO use regex to parse\n    } finally {\n      return this.insomnia_to_oas_params(params, 'query');\n    }\n  }\n\n  _get_schema(inputJsonObject: any) {\n    let { title, $schema, ...schema } = GenerateSchema.json(\n      'insomnia',\n      inputJsonObject\n    );\n    return schema;\n  }\n\n  get_spec(): SpecExporter {\n    return new SpecExporter(this.builder);\n  }\n}\n\nexport default OpenapiCollector;\n","import * as types from './types/insomnia';\nimport OpenapiCollector from './collector';\nimport * as utils from './utils';\nimport SpecExporter from './exporter';\n\nclass SchemaConventer {\n  config = {\n    title: 'Api',\n    description: '',\n    version: '1.0.0',\n    baseUrl: 'http://example.tld',\n  };\n\n  validated = false;\n  validationResult = {};\n\n  collector!: OpenapiCollector;\n\n  json = {\n    _type: 'export',\n    __export_format: 4,\n    __export_date: new Date().toString(),\n    __export_source: 'openapi-converter-plugin',\n    resources: <types.InsomniaResource[]>[],\n  };\n\n  constructor(json: types.InsomniaExport, config: any) {\n    this.json = json;\n    this.config = this.getConfig(config);\n    this.validated = false;\n    this.validationResult = {};\n  }\n\n  getConfig(config: any): types.InsomniaConfig {\n    config = Object.assign({}, config || {});\n    return { ...this.config, ...config };\n  }\n\n  getInsomniaResources(): types.InsomniaResource[] {\n    return this.sortInsomniaResources(this.json.resources);\n  }\n\n  sortInsomniaResources(\n    resources: types.InsomniaResource[]\n  ): types.InsomniaResource[] {\n    let environment = resources.filter(\n      (r) => r._type == utils.types.ENVIRONMENT\n    );\n    let requests = resources.filter((r) => r._type == utils.types.REQUEST);\n    let folders = resources.filter((r) => r._type == utils.types.FOLDER);\n    let workspaces = resources.filter((r) => r._type == utils.types.WORKSPACE);\n    let cookies = resources.filter((r) => r._type == utils.types.COOKIE);\n    let specs = resources.filter((r) => r._type == utils.types.SPEC);\n\n    // env > req > folder > workspace\n    return [\n      ...environment,\n      ...requests,\n      ...folders,\n      ...workspaces,\n      ...cookies,\n      ...specs,\n    ];\n  }\n\n  convert(): SpecExporter | null {\n    this.collector = new OpenapiCollector();\n\n    // Add openapi info\n    this.collector.addInfo(this.config);\n    // Json to insomnia classes\n    let resources = this.getInsomniaResources();\n\n    for (let resource of resources) {\n      if (resource._type == utils.types.FOLDER) {\n        let linkedRequest = utils.getRequestFromFolder(resource, resources);\n        // We add the folder only if it is directly linked to request\n        if (linkedRequest !== null)\n          this.collector.addFolderToRequest(\n            <types.InsomniaFolder>resource,\n            linkedRequest\n          );\n      }\n\n      if (resource._type == utils.types.ENVIRONMENT) {\n        this.collector.addEnvironment(<types.InsomniaEnvironment>resource);\n      }\n\n      if (resource._type == utils.types.REQUEST) {\n        try {\n          this.collector.addRequest(<types.InsomniaRequest>resource);\n        } catch (e) {\n          this.validationResult = {\n            result: false,\n            reason: e,\n          };\n          return null;\n        }\n      }\n    }\n\n    return this.collector.get_spec();\n  }\n}\n\nexport default SchemaConventer;\n"],"names":["insomniaTemplateRegex","getRequestFromFolder","resource","resources","foundRequests","filter","r","parentId","_id","length","pop","replaceInsomniaTemplateWithVars","variable","envVars","matches","toString","matchAll","match","trimmedMatch","trim","replace","hasHttp","path","includes","urlFromPath","URL","keepInsomniaFormat","trimTemplate","sanitizeRequestMethod","method","toLowerCase","yaml","require","SpecExporter","spec","as_yaml","dump","this","as_dict","as_json","formatted","specjson","getSpecAsJson","JSON","stringify","parse","error","console","warn","getSpec","GenerateSchema","OpenapiCollector","builder","oas","addInfo","config","addTitle","title","addDescription","description","addVersion","version","add_url","baseUrl","getRequestFromOas","oasPath","rootDoc","paths","addFolderToRequest","folder","request","folderName","name","addTag","updateRequest","tags","addEnvironment","env","args","sanitizedMethod","utils","get_path_pathparams","url","oasRequest","pathObject","Object","assign","addPath","pathInfo","_get_oas_pathparams","Error","params","addRequest","pathItem","summary","methodName","headers","insomnia_to_oas_params","queryParams","get_query_params","parameters","keys","body","requestBody","get_request_body","responses","get_responses","examples","oasResponsesBody","oasResponseBody","content","example","schema","exampleBody","contentType","e","info","_get_schema","responseObject","existingSchema","oneOf","exampleObj","id","statusCode","oasRequestBody","mimeType","jsonBody","text","bodyParams","insomniaFormParams","param","value","additionalProperties","queryParamsFromurl","_get_oas_query_params_from_url","queryParamsFromParams","urlQueryNames","map","q","indexOf","_get_from_env","key","servers","s","addServer","uri","parsedPath","parsedPathParams","origin","decodeURIComponent","pathname","Array","from","m","p","push","insomniaParams","_in","_key","_value","_param","searchParams","inputJsonObject","json","get_spec","_type","__export_format","__export_date","Date","__export_source","getConfig","validated","validationResult","getInsomniaResources","sortInsomniaResources","environment","requests","folders","workspaces","cookies","specs","convert","collector","linkedRequest","result","reason"],"mappings":"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"}